-- Enable pgvector extension for vector operations
CREATE EXTENSION IF NOT EXISTS vector;

-- Create memory_embeddings table for storing vector embeddings
CREATE TABLE IF NOT EXISTS memory_embeddings (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    content_text TEXT NOT NULL,
    content_type VARCHAR(50) NOT NULL, -- 'meeting', 'summary', 'task', 'decision', 'note'
    content_id UUID NOT NULL, -- ID of the original content (meeting_id, task_id, etc.)
    embedding VECTOR(1536), -- OpenAI text-embedding-3-small dimensions
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create memory_search_logs table for tracking search queries
CREATE TABLE IF NOT EXISTS memory_search_logs (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    query TEXT NOT NULL,
    query_embedding VECTOR(1536),
    threshold DECIMAL(3,2) DEFAULT 0.7,
    limit_count INTEGER DEFAULT 10,
    results_count INTEGER DEFAULT 0,
    search_duration_ms INTEGER,
    user_id UUID,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_memory_embeddings_content_type ON memory_embeddings(content_type);
CREATE INDEX IF NOT EXISTS idx_memory_embeddings_content_id ON memory_embeddings(content_id);
CREATE INDEX IF NOT EXISTS idx_memory_embeddings_created_at ON memory_embeddings(created_at);
CREATE INDEX IF NOT EXISTS idx_memory_search_logs_created_at ON memory_search_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_memory_search_logs_user_id ON memory_search_logs(user_id);

-- Create vector similarity search function
CREATE OR REPLACE FUNCTION search_memory(
    query_embedding VECTOR(1536),
    match_threshold DECIMAL(3,2) DEFAULT 0.7,
    match_count INTEGER DEFAULT 10
)
RETURNS TABLE (
    id UUID,
    content_text TEXT,
    content_type VARCHAR(50),
    content_id UUID,
    metadata JSONB,
    similarity DECIMAL(3,2)
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        me.id,
        me.content_text,
        me.content_type,
        me.content_id,
        me.metadata,
        1 - (me.embedding <=> query_embedding) AS similarity
    FROM memory_embeddings me
    WHERE me.embedding IS NOT NULL
    AND 1 - (me.embedding <=> query_embedding) > match_threshold
    ORDER BY me.embedding <=> query_embedding
    LIMIT match_count;
END;
$$;

-- Create function to generate embeddings (placeholder - will be called from Edge Function)
CREATE OR REPLACE FUNCTION generate_embedding(text_content TEXT)
RETURNS VECTOR(1536)
LANGUAGE plpgsql
AS $$
BEGIN
    -- This is a placeholder function
    -- The actual embedding generation will be done in the Edge Function using OpenAI
    RETURN NULL;
END;
$$;

-- Create triggers to automatically create/update embeddings when content is modified

-- Trigger for meetings table
CREATE OR REPLACE FUNCTION create_meeting_embedding()
RETURNS TRIGGER AS $$
BEGIN
    -- Delete existing embedding if it exists
    DELETE FROM memory_embeddings 
    WHERE content_type = 'meeting' AND content_id = NEW.id;
    
    -- Insert new embedding (embedding will be generated by Edge Function)
    INSERT INTO memory_embeddings (content_text, content_type, content_id, metadata)
    VALUES (
        COALESCE(NEW.title, '') || ' ' || COALESCE(NEW.description, ''),
        'meeting',
        NEW.id,
        jsonb_build_object(
            'title', NEW.title,
            'date', NEW.date,
            'participants', NEW.participants,
            'created_at', NEW.created_at
        )
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_meeting_embedding
    AFTER INSERT OR UPDATE ON meetings
    FOR EACH ROW
    EXECUTE FUNCTION create_meeting_embedding();

-- Trigger for tasks table
CREATE OR REPLACE FUNCTION create_task_embedding()
RETURNS TRIGGER AS $$
BEGIN
    -- Delete existing embedding if it exists
    DELETE FROM memory_embeddings 
    WHERE content_type = 'task' AND content_id = NEW.id;
    
    -- Insert new embedding
    INSERT INTO memory_embeddings (content_text, content_type, content_id, metadata)
    VALUES (
        COALESCE(NEW.task, '') || ' ' || COALESCE(NEW.description, ''),
        'task',
        NEW.id,
        jsonb_build_object(
            'task', NEW.task,
            'assignee', NEW.assignee,
            'priority', NEW.priority,
            'completed', NEW.completed,
            'due_date', NEW.due_date,
            'created_at', NEW.created_at
        )
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_task_embedding
    AFTER INSERT OR UPDATE ON tasks
    FOR EACH ROW
    EXECUTE FUNCTION create_task_embedding();

-- Trigger for summaries table
CREATE OR REPLACE FUNCTION create_summary_embedding()
RETURNS TRIGGER AS $$
BEGIN
    -- Delete existing embedding if it exists
    DELETE FROM memory_embeddings 
    WHERE content_type = 'summary' AND content_id = NEW.id;
    
    -- Insert new embedding
    INSERT INTO memory_embeddings (content_text, content_type, content_id, metadata)
    VALUES (
        COALESCE(NEW.summary, ''),
        'summary',
        NEW.id,
        jsonb_build_object(
            'meeting_id', NEW.meeting_id,
            'ai_model', NEW.ai_model,
            'created_at', NEW.created_at
        )
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_summary_embedding
    AFTER INSERT OR UPDATE ON summaries
    FOR EACH ROW
    EXECUTE FUNCTION create_summary_embedding();

-- Add description column to meetings table if it doesn't exist
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                   WHERE table_name = 'meetings' AND column_name = 'description') THEN
        ALTER TABLE meetings ADD COLUMN description TEXT;
    END IF;
END $$;

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO anon, authenticated; 